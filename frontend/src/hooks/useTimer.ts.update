// Import the notification utilities
import { showTimerNotification } from '../utils/notifications/TimerNotifications';
import { useTranslation } from 'react-i18next';

// In the useTimer hook, add:
const { t } = useTranslation();

// Update the tick function to add notifications when phases change
tick: (delta) =>
  set((state) => {
    if (state.status === 'running') {
      const newElapsed = state.elapsed + delta;
      const totalDuration =
        state.mode === 'work'
          ? state.workDuration * 60 * 1000
          : state.breakDuration * 60 * 1000;

      // If the timer has finished its current phase
      if (newElapsed >= totalDuration) {
        // If we're in work mode, create time entry and switch to break
        if (state.mode === 'work') {
          // We'll handle the time entry creation in the next tick
          // to avoid async operations here
          setTimeout(() => {
            get().createTimeEntryFromWorkSession();
            
            // Show notification for completed work session
            showTimerNotification('break', {
              title: t('timer.breakTime'),
              body: t('timer.workCompleted'),
              persistent: false
            });
          }, 0);

          return {
            mode: 'break',
            status: 'running',
            elapsed: 0,
            workStartTime: null,
          };
        }
        // If we're in break mode
        else {
          // If we haven't completed all repetitions, start a new work period
          if (state.currentRepetition < state.repetitions) {
            // Show notification for completed break session
            setTimeout(() => {
              showTimerNotification('work', {
                title: t('timer.workTime'),
                body: t('timer.breakCompleted'),
                persistent: false
              });
            }, 0);
            
            return {
              mode: 'work',
              status: 'running',
              elapsed: 0,
              currentRepetition: state.currentRepetition + 1,
              workStartTime: new Date(),
            };
          }
          // If we've completed all repetitions, stop the timer
          else {
            // Show notification for completed all sessions
            setTimeout(() => {
              showTimerNotification('complete', {
                title: t('timer.sessionsCompleted'),
                body: t('timer.allSessionsCompleted'),
                persistent: true
              });
            }, 0);
            
            return {
              mode: 'work',
              status: 'idle',
              elapsed: 0,
              currentRepetition: 1,
              workStartTime: null,
            };
          }
        }
      }

      // Otherwise, just update the elapsed time
      return { elapsed: newElapsed };
    }
    return state;
  }),

// Modify createTimeEntryFromWorkSession to add notification
createTimeEntryFromWorkSession: async () => {
  const state = get();

  // Skip if not in work mode or no project selected
  if (!state.projectId) {
    console.log('No project selected, skipping time entry creation');
    return;
  }

  try {
    const startTime = state.workStartTime || new Date(Date.now() - state.elapsed);
    const endTime = new Date();
    const duration = endTime.getTime() - startTime.getTime();

    console.log('Creating time entry from work session:', {
      project: state.projectId,
      task: state.taskId,
      startTime,
      endTime,
      duration,
      notes: state.notes,
      tags: state.tags,
    });

    // Use the time entry store to create the entry
    const timeEntryStore = useTimeEntryStore.getState();

    await timeEntryStore.createTimeEntry({
      project: state.projectId,
      task: state.taskId || undefined,
      startTime,
      endTime,
      duration,
      notes: state.notes || `Work session ${state.currentRepetition}/${state.repetitions}`,
      tags: state.tags,
      isRunning: false,
    });

    console.log('Time entry created successfully');
    
    // Show notification for created time entry
    showTimerNotification('timeEntry', {
      title: t('timeEntries.created'),
      body: t('timeEntries.entryCreated', { 
        duration: Math.floor(duration / 60000) // Convert ms to minutes
      }),
      persistent: false
    });
  } catch (error) {
    console.error('Error creating time entry from work session:', error);
  }
},

// Also modify switchToNext to add notifications
switchToNext: () =>
  set((state) => {
    // If we're in work mode, create time entry and switch to break
    if (state.mode === 'work' && state.projectId) {
      // Create time entry in the next tick
      setTimeout(() => {
        get().createTimeEntryFromWorkSession();
        
        // Show notification for switching to break
        showTimerNotification('break', {
          title: t('timer.breakTime'),
          body: t('timer.workCompleted'),
          persistent: false
        });
      }, 0);

      return {
        mode: 'break',
        status: 'running',
        elapsed: 0,
        workStartTime: null,
      };
    }
    // If we're in break mode
    else {
      // Show notification for switching to work
      setTimeout(() => {
        showTimerNotification('work', {
          title: t('timer.workTime'),
          body: t('timer.breakCompleted'),
          persistent: false
        });
      }, 0);
      
      // If we haven't completed all repetitions, start a new work period
      if (state.currentRepetition < state.repetitions) {
        return {
          mode: 'work',
          status: 'running',
          elapsed: 0,
          currentRepetition: state.currentRepetition + 1,
          workStartTime: new Date(),
        };
      }
      // If we've completed all repetitions, start over
      else {
        return {
          mode: 'work',
          status: 'running',
          elapsed: 0,
          currentRepetition: 1,
          workStartTime: new Date(),
        };
      }
    }
  }),
